import type { Desconto, TipoDesconto } from "@/features/enrollment/types";
import { MAX_DESCONTO_TOTAL, TIPOS_DESCONTO } from "@/features/enrollment/constants";

export type ChecklistItem = {
  id: string;
  label: string;
  required: boolean;
};

// Cat√°logo de documentos por n√∫mero conforme PRD
export const DOCUMENT_CATALOG: Record<string, string> = {
  "1": "C√≥pia da identidade e certid√µes de nascimento dos irm√£os",
  "2": "Comprovante de resid√™ncia fora de Po√ßos de Caldas-MG",
  "4": "Comprovante de filia√ß√£o ao SINPRO-MG",
  "5": "Comprovante de v√≠nculo trabalhista (SAAE/Institui√ß√£o)",
  "6": "Comprovante de membro ativo da Loja Ma√ß√¥nica Estrela Caldense",
  "7": "Comprovante de v√≠nculo familiar com membro da Loja",
  "8": "Certid√£o de s√≥cio da Loja Ma√ß√¥nica Estrela Caldense",
  "9": "Certid√£o de membro ativo de outras Lojas Ma√ß√¥nicas",
  "10": "Certid√£o de av√¥ membro da Loja Ma√ß√¥nica Estrela Caldense",
  "11": "Comprovante de v√≠nculo familiar (certid√£o nascimento/casamento)",
  // 12-19: pacotes socioecon√¥micos
  "12": "Formul√°rio socioecon√¥mico preenchido",
  "13": "Comprovantes de renda do n√∫cleo familiar",
  "14": "Comprovante de resid√™ncia",
  "15": "Declara√ß√£o de composi√ß√£o familiar",
  "16": "Despesas essenciais (√°gua, luz, alimenta√ß√£o)",
  "17": "Declara√ß√£o de imposto de renda ou isen√ß√£o",
  "18": "Situa√ß√£o habitacional (aluguel/financiamento)",
  "19": "Outros documentos comprobat√≥rios pertinentes",
  PAV: "Comprovante de pagamento integral anual",
};

// Mapeamento de c√≥digos -> documentos requeridos
export const DOCUMENTS_BY_CODIGO: Record<string, string[]> = {
  IIR: ["1"],
  RES: ["2"],
  PASS: ["4"],
  PBS: ["4"],
  COL: ["5"],
  SAE: ["5"],
  LEC: ["6", "7"],
  FBM: ["6", "8"],
  MAC: ["9", "7"],
  NEC: ["10", "11"],
  ABI: ["12", "13", "14", "15", "16", "17", "18", "19"],
  ABP: ["12", "13", "14", "15", "16", "17", "18", "19"], // parcial: revis√£o manual
  PAV: ["PAV"],
};

export function getChecklistForCodigo(codigo: string): ChecklistItem[] {
  const ids = DOCUMENTS_BY_CODIGO[codigo] ?? [];
  return ids.map((id) => ({ id, label: DOCUMENT_CATALOG[id], required: true }));
}

// =============================================================================
// SISTEMA DE DOCUMENTA√á√ÉO DIN√ÇMICO
// =============================================================================

/**
 * Fun√ß√£o migrada que busca checklist de documentos dinamicamente
 */
export function getDynamicChecklistForCode(
  codigo: string, 
  dynamicTypes?: any[], 
  fallbackToStatic = true
): ChecklistItem[] {
  // üîÑ MIGRA√á√ÉO PROGRESSIVA: Tentar dados din√¢micos primeiro
  if (dynamicTypes && dynamicTypes.length > 0) {
    const dynamicType = dynamicTypes.find(t => t.codigo === codigo);
    if (dynamicType?.documentos_necessarios && Array.isArray(dynamicType.documentos_necessarios)) {
      return dynamicType.documentos_necessarios.map((doc: string, index: number) => ({
        id: `${codigo}_${index}`,
        label: doc,
        required: true
      }));
    }
  }

  // üéØ FALLBACK: Usar sistema est√°tico se din√¢mico n√£o dispon√≠vel
  if (fallbackToStatic) {
    return getChecklistForCodigo(codigo);
  }

  return [];
}

/**
 * Fun√ß√£o utilit√°ria para converter documentos est√°ticos em formato din√¢mico
 */
export function migrateStaticDocsToDynamic(): Record<string, string[]> {
  const dynamicDocs: Record<string, string[]> = {};
  
  Object.entries(DOCUMENTS_BY_CODIGO).forEach(([codigo, docIds]) => {
    dynamicDocs[codigo] = docIds.map(id => DOCUMENT_CATALOG[id]).filter(Boolean);
  });

  return dynamicDocs;
}

export function calculateTotals(
  baseMensal: number,
  descontos: Desconto[],
  tipos: TipoDesconto[] = TIPOS_DESCONTO,
  maxDiscountLimit: number = MAX_DESCONTO_TOTAL
) {
  const items = descontos.map((d) => {
    const tipo = tipos.find((t) => t.id === d.tipo_desconto_id || t.codigo === d.codigo_desconto);
    const percentual = d.percentual_aplicado ?? tipo?.percentual_fixo ?? 0;
    return {
      id: d.id,
      codigo: d.codigo_desconto,
      descricao: tipo?.descricao ?? tipo?.nome ?? d.codigo_desconto,
      percentual,
      status: d.status_aprovacao,
      dataVenc: d.data_vencimento || null,
    };
  });

  const totalPercent = items.reduce((acc, it) => acc + (it.percentual || 0), 0);
  const cappedPercent = Math.min(totalPercent, maxDiscountLimit);
  const percentualEfetivo = isFinite(cappedPercent) ? Math.max(0, cappedPercent) : 0;

  const finalValue = baseMensal > 0 ? Number((baseMensal * (1 - percentualEfetivo / 100)).toFixed(2)) : 0;
  const savingsMonthly = baseMensal > 0 ? Number((baseMensal - finalValue).toFixed(2)) : 0;
  const savingsAnnual = Number((savingsMonthly * 12).toFixed(2));

  return {
    items,
    totalPercent,
    cappedPercent,
    capReached: totalPercent > maxDiscountLimit,
    finalValue,
    savingsMonthly,
    savingsAnnual,
    maxDiscountLimit, // Retornar o limite usado para refer√™ncia
  } as const;
}

// =============================================================================
// FUN√á√ïES MIGRADAS PARA DADOS DIN√ÇMICOS
// =============================================================================

/**
 * Vers√£o aprimorada do calculateTotals que usa dados din√¢micos por padr√£o
 * @deprecated Use calculateTotalsWithDynamic para nova implementa√ß√£o
 */
export function calculateTotalsWithDynamic(
  baseMensal: number,
  descontos: Desconto[],
  options: {
    tipos?: TipoDesconto[];
    maxDiscountLimit?: number;
    fallbackToStatic?: boolean;
  } = {}
) {
  const {
    tipos = TIPOS_DESCONTO,
    maxDiscountLimit = MAX_DESCONTO_TOTAL,
    fallbackToStatic = true,
  } = options;

  return calculateTotals(baseMensal, descontos, tipos, maxDiscountLimit);
}
